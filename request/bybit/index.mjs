/**
 * Request Bybit API spot endpoints.
 * Each account can have up to 20 keys.
 * API keys that are bound to IP addresses are permanently valid.
 * API keys that are not bound to IP addresses are valid for 3 months.
 * After changing login password API keys will expire within 7 days.
 * API keys generated by the Bybit operates with HMAC encryption: you will be provided with a pair of public and private keys.
 * Self-generated API keys operate with RSA encryption: user creates them by the software and only provides the public key.
 * Withdrawal permission requires IP restriction.
 *
 * @see https://www.bybit.com/app/user/api-management
 * @see https://www.bybit.com/app/user/add-secret-key?type=auto
 * @see https://www.bybit.com/app/user/add-secret-key?type=system
 * @see https://www.bybit.com/user/assets/money-address
 * @typedef {import("#types/response/bybit.d.js").default} Response
 * @module request/bybit/index
 */

import { argv } from 'node:process';

import config from '#config/bybit.json' with { type: 'json' };
import { NUMBER } from '#lib/constants.mjs';
import { dirObject } from '#lib/output.mjs';
import { optional } from '#lib/template.mjs';
import { parseArguments } from '#lib/utility.mjs';
import prefs from '#prefs/bybit.json' with { type: 'json' };
import status from '#res/bybit/status.json' with { type: 'json' };
import settings from '#settings/bybit.json' with { type: 'json' };

import accountInformation from './account/information.mjs';
import accountWallets from '../bybit/account/wallets.mjs';
import balanceAll from '../bybit/balance/all.mjs';
import balanceInformation from '../bybit/balance/information.mjs';
import balanceOne from '../bybit/balance/one.mjs';
import currencyAll from '../bybit/currency/all.mjs';
import currencyNetworkAll from '../bybit/currency/network-all.mjs';
import currencyNetworkOne from '../bybit/currency/network-one.mjs';
import currencyOne from '../bybit/currency/one.mjs';
import depositAll from '../bybit/deposit/all.mjs';
import depositNewMaster from '../bybit/deposit/new-master.mjs';
import depositNewSub from '../bybit/deposit/new-sub.mjs';
import depositOne from '../bybit/deposit/one.mjs';
import keyInformation from '../bybit/key/information.mjs';
import marketHistory from '../bybit/market/history.mjs';
import marketInformation from '../bybit/market/information.mjs';
import marketTickers from '../bybit/market/tickers.mjs';
import orderAll from '../bybit/order/all.mjs';
import orderBook from '../bybit/order/book.mjs';
import orderCancelAll from '../bybit/order/cancel-all.mjs';
import orderCancelOne from '../bybit/order/cancel-one.mjs';
import orderHistoryAll from '../bybit/order/history-all.mjs';
import orderHistoryOne from '../bybit/order/history-one.mjs';
import orderOne from '../bybit/order/one.mjs';
import orderLimitBuy from '../bybit/order/limit-buy.mjs';
import orderLimitSell from '../bybit/order/limit-sell.mjs';
import orderMarketBuy from '../bybit/order/market-buy.mjs';
import orderMarketSell from '../bybit/order/market-sell.mjs';
import tradeRates from '../bybit/trade/rates.mjs';
import tradeHistoryAll from '../bybit/trade/history-all.mjs';
import tradeHistoryOne from '../bybit/trade/history-one.mjs';
import transferAll from '../bybit/transfer/all.mjs';
import transferInternal from '../bybit/transfer/internal.mjs';
import transferOne from '../bybit/transfer/one.mjs';
import withdrawAll from '../bybit/withdraw/all.mjs';
import withdrawNew from '../bybit/withdraw/new.mjs';
import withdrawOne from '../bybit/withdraw/one.mjs';

const {
    DATE: { DAY },
  } = NUMBER,
  {
    account: { SPOT, UNIFIED },
    address: { deposit, withdraw },
  } = settings,
  { debug } = prefs,
  timestamp = Date.now();

/**
 * @returns {Promise<Response>}
 */
const requestBybit = async () => {
  /**
   * Global types for each API are defined in `#types/global.d.ts`
   * @type {any}
   */
  const bybit = {
      config,
      name: 'bybit',
      prefs,
      settings,
      status,
    },
    { handler, options, params } = parseArguments(argv);

  global.apiTools = { bybit, options, output: {}, timestamp };
  if (debug || options.debug) dirObject('global.apiTools', global.apiTools);
  if (handler) {
    switch (handler) {
      case 'account':
      case 'accountInfo':
      case 'accountInformation':
        return await accountInformation(...params);
      case 'accountWallets':
        return accountWallets(...params);
      case 'balanceAll':
        return await balanceAll(...params);
      case 'balanceInfo':
      case 'balanceInformation':
        return await balanceInformation(...params);
      case 'balance':
      case 'balanceOne':
        return await balanceOne(...params);
      case 'currencyAll':
        return await currencyAll(...params);
      case 'currencyNetworkAll':
        return await currencyNetworkAll(...params);
      case 'currencyNetwork':
      case 'currencyNetworkOne':
        return await currencyNetworkOne(...params);
      case 'currency':
      case 'currencyOne':
        return await currencyOne(...params);
      case 'depositAll':
        return await depositAll(...params);
      case 'depositNew':
      case 'depositNewMaster':
        return await depositNewMaster(...params);
      case 'depositNewSub':
        return await depositNewSub(...params);
      case 'deposit':
      case 'depositOne':
        return await depositOne(...params);
      case 'key':
      case 'keyInfo':
      case 'keyInformation':
        return await keyInformation(...params);
      case 'marketHistory':
        return await marketHistory(...params);
      case 'market':
      case 'marketInfo':
      case 'marketInformation':
        return await marketInformation(...params);
      case 'marketTickers':
        return await marketTickers(...params);
      case 'orderAll':
        return await orderAll(...params);
      case 'orderBook':
        return await orderBook(...params);
      case 'orderCancelAll':
        return await orderCancelAll(...params);
      case 'orderCancel':
      case 'orderCancelOne':
        return await orderCancelOne(...params);
      case 'orderHistoryAll':
        return await orderHistoryAll(...params);
      case 'orderHistory':
      case 'orderHistoryOne':
        return await orderHistoryOne(...params);
      case 'order':
      case 'orderOne':
        return await orderOne(...params);
      case 'orderLimit':
      case 'orderLimitBuy':
        return await orderLimitBuy(...params);
      case 'orderLimitSell':
        return await orderLimitSell(...params);
      case 'orderMarket':
      case 'orderMarketBuy':
        return await orderMarketBuy(...params);
      case 'orderMarketSell':
        return orderMarketSell(...params);
      case 'tradeRates':
        return await tradeRates(...params);
      case 'tradeHistoryAll':
        return tradeHistoryAll(...params);
      case 'tradeHistory':
      case 'tradeHistoryOne':
        return await tradeHistoryOne(...params);
      case 'transferAll':
        return await transferAll(...params);
      case 'transfer':
      case 'transferOne':
        return await transferOne(...params);
      case 'transferInternal':
        return await transferInternal(...params);
      case 'withdrawAll':
        return await withdrawAll(...params);
      case 'withdraw':
      case 'withdrawOne':
        return await withdrawOne(...params);
      case 'withdrawNew':
        return await withdrawNew(...params);
      default:
        throw new Error(requestBybit.name + ': ' + optional(handler));
    }
  } else {
    switch (options.flow) {
      case 'account':
        return await accountFlow();
      case 'balance':
        return await balanceFlow();
      case 'currency':
        return await currencyFlow();
      case 'deposit':
        return await depositFlow();
      case 'key':
        return await keyInformation();
      case 'market':
        return await marketFlow();
      case 'order':
        return await orderFlow();
      case 'trade':
        return await tradeFlow();
      case 'transfer':
        return await transferFlow();
      case 'withdraw':
        return await withdrawFlow();
      default:
        return await Promise.resolve()
          .then((response) => accountFlow())
          .then((response) => balanceFlow())
          .then((response) => currencyFlow())
          .then((response) => depositFlow())
          .then((response) => keyInformation())
          .then((response) => marketFlow())
          .then((response) => orderFlow())
          .then((response) => tradeFlow())
          .then((response) => transferFlow())
          .then((response) => withdrawFlow())
          .catch(console.error.bind(console));
    }
  }
};

/**
 * @returns {Promise<Response>}
 */
const accountFlow = () =>
  Promise.resolve()
    .then((response) => accountInformation())
    .then((response) => accountWallets([SPOT, UNIFIED].join()))
    .catch(console.error.bind(console));

/**
 * @returns {Promise<Response>}
 */
const balanceFlow = () =>
  Promise.resolve()
    .then((response) => balanceAll('UNIFIED', UNIFIED, { coin: 'SHIB', withBonus: '1' }))
    .then((response) => balanceInformation('UNIFIED', 'USDT'))
    .then((response) => balanceOne('FUND', 'USDT', SPOT, { withBonus: '1' }))
    .catch(console.error.bind(console));

/**
 * @returns {Promise<Response>}
 */
const currencyFlow = () =>
  Promise.resolve()
    .then((response) => currencyAll())
    .then((response) => currencyNetworkAll())
    .then((response) => currencyNetworkOne('AVAX', 'CAVAX'))
    .then((response) => currencyOne('AVAX'))
    .catch(console.error.bind(console));

/**
 * @returns {Promise<Response>}
 */
const depositFlow = () =>
  Promise.resolve()
    .then((response) =>
      depositAll('USDC', {
        endTime: timestamp,
        limit: 1,
        startTime: timestamp - DAY * 30,
      }),
    )
    .then((response) => depositNewMaster('USDC', 'CAVAX'))
    .then((response) => depositNewSub('219021948', 'USDC', 'CAVAX'))
    .then((response) =>
      depositOne(deposit, {
        coin: 'USDC',
        endTime: timestamp,
        limit: 1,
        startTime: timestamp - DAY * 30,
      }),
    )
    .catch(console.error.bind(console));

/**
 * @returns {Promise<Response>}
 */
const marketFlow = () =>
  Promise.resolve()
    .then((response) =>
      marketHistory('SHIBUSDT', '2', {
        baseCoin: 'SHIB',
        category: 'spot',
        optionType: 'Call',
      }),
    )
    .then((response) =>
      marketInformation('spot', {
        baseCoin: 'BTC',
        limit: '2',
        status: 'Trading',
        symbol: 'SHIBUSDT',
      }),
    )
    .then((response) =>
      marketTickers('BONKUSDT', {
        baseCoin: 'BTC',
        category: 'spot',
      }),
    )
    .catch(console.error.bind(console));

/**
 * @returns {Promise<Response>}
 */
const orderFlow = () =>
  Promise.resolve()
    .then((response) => orderAll('NOTUSDT', 'Buy', '2'))
    .then((response) => orderBook('NOTUSDT', 'inverse', '2'))
    .then((response) => orderHistoryAll('NOTUSDT', '2'))
    .then((response) => orderHistoryOne(response.result.list[0]?.orderId ?? '0000000000000000000'))
    .then((response) => orderCancelAll())
    .then((response) => orderMarketBuy('1'))
    .then((response) => orderMarketSell('100'))
    .then((response) => orderLimitBuy('100', '0.002'))
    .then((response) => orderOne(response.result.orderId))
    .then((response) => orderLimitSell('100', '2'))
    .then((response) => orderCancelOne(response.result.orderId))
    .then((response) => orderCancelAll('NOTUSDT'))
    .catch(console.error.bind(console));

/**
 * @returns {Promise<Response>}
 */
const tradeFlow = () =>
  Promise.resolve()
    .then((response) => tradeHistoryAll())
    .then((response) => tradeHistoryOne(response.result.list[0]?.orderId ?? '0000000000000000000'))
    .then((response) => tradeRates('NOTUSDT'))
    .catch(console.error.bind(console));

/**
 * @returns {Promise<Response>}
 */
const transferFlow = () =>
  Promise.resolve()
    .then((response) => transferAll('FUND'))
    .then((response) => transferInternal('FUND', '1'))
    .then((response) => transferOne('FUND', 'NOT'))
    .catch(console.error.bind(console));

/**
 * @returns {Promise<Response>}
 */
const withdrawFlow = () =>
  Promise.resolve()
    .then((response) => withdrawAll())
    .then((response) => withdrawOne(response.result.rows[0]?.txID ?? withdraw))
    .then((response) => withdrawNew('1', 'NOT'))
    .catch(console.error.bind(console));

export default requestBybit;
